import argparse
import random
import time
import csv
import cv2
from keras.models import load_model
import numpy as np


parser = argparse.ArgumentParser()
parser.add_argument('-m', '--mode', type=str, default='keyboard', help='user input method to play game: "keyboard" or "camera"' )
args = parser.parse_args()


class RPS:
    """
    The class RPS contains all the methods for playing a game of rock, paper, scissors.
    It gets the computer and user choices (either by keyboard input or by camera), finds the winner of each round as well as the overall winner.

    Parameters:

        moves (list): labels from the 'labels.txt' file is read into this list
        prediction_index (int): index of the highest probability in the array generated by Keras, initiated to 0
        computer_wins (int): number of times the computer wins a round of the game (counter)
        user_wins (int): number of times the user wins a round of the game (counter)
        game_round (int): variable to keep track of the number of rounds of the game played, initiated to 1
    """

    def __init__(self):

        self.moves = []
        self.prediction_index = 0
        self.computer_wins = 0
        self.user_wins = 0
        self.game_round = 1
        

    @staticmethod
    def get_countdown():
        """
        A method to create and print a visible 3-second countdown to prompt the user to present their move to the camera.
        """

        print("Get ready to show your move!")
        countdown = 3
        
        while countdown > 0:
            minute, sec = divmod(countdown, 60)
            print(sec)
            cv2.waitKey(1000)
            countdown -= 1
            if countdown == 0:
                print("Show your move!") 
    

    def get_labels(self):
        """
        A method to read the 'labels.txt' file generated by teachable machine and generate a list of moves. 
        The index of each move relates to the index labels in the 'labels.txt' file.
        The output is a list of moves from labels.txt: ['Rock', 'Paper', 'Scissors', 'Nothing'].
        """

        label_file = 'labels.txt'
        
        with open(label_file) as f:
            reader = csv.reader(f, delimiter=' ')
            label_dict = dict(reader)
            
            for k, v in label_dict.items():
                self.moves.append(v)

        self.moves = [word.lower() for word in self.moves]
        
        return self.moves 


    def get_computer_choice(self):
        """
        A method to generate the computer's move by randomly selecting an option from the list of moves (created by the 'get_labels' method).
        The move 'Nothing' is excluded from the list of moves the computer can select.
        """

        computer_choice = random.choice(self.moves[:-1])
        # print(f"COMPUTER CHOICE: {computer_choice}")

        return computer_choice 


    def get_prediction(self):
        """
        A method to capture the image from the user's camera and and make a prediction of the move (rock, paper, scissors, nothing) with Tensorflow.
        The 'end' variable and 'while' loop allows the camera to capture frames for up to 2 seconds, at which point it must use the final frame to make the prediction. 
        The prediction returns an array of the probability for each move, from which the highest probability is chosen using the argmax function.
        The method returns the index of the highest probability, which is used in the 'get_user_choice' method to return the corresponding move to that index.
        """
        
        self.cap = cv2.VideoCapture(0) # Open a camera for video capturing. To open default camera using default backend just pass 0.
        data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32) # construct a numpy array to read in data from image 224 x 224 pixels and 3 colour channels (RGB)
        model = load_model('keras_model.h5') #load model ready to make prediction
        end = time.time() + 2

        while time.time() < end:
            ret, frame = self.cap.read()
            resized_frame = cv2.resize(frame, (224, 224), interpolation = cv2.INTER_AREA)
            image_np = np.array(resized_frame)
            normalized_image = (image_np.astype(np.float32) / 127.0) - 1 # Normalize the image, ready to be read/used by tensorflow
            data[0] = normalized_image
            prediction = model.predict(data)
            cv2.imshow('frame', frame)
            self.prediction_index = np.argmax(prediction)

        return self.prediction_index


    def get_camera_user_choice(self, prediction_index):
        """
        A method which takes in the index of the highest probability from the 'prediction' array and returns the corresponding move to that index.
        """

        camera_user_choice = self.moves[prediction_index]
        print(f"USER CHOICE: {camera_user_choice}")
        
        return camera_user_choice


    def get_keyboard_user_choice(self):
        """
        A method to ask the player to input their move via the keyboard and verify it. 
        """

        keyboard_user_choice = input("What move will you play: Rock, Paper or Scissors?\t")
        keyboard_user_choice = keyboard_user_choice.lower()
        
        if keyboard_user_choice not in self.moves:
            print("Oops! That is not a recognised move. Your choices are: 'Rock' , 'Paper' or 'Scissors'")

        return keyboard_user_choice


    def get_winner(self, computer_choice, user_choice):
        """
        A method to compare the user choice and computer choice to determine the winner of a round.
        """

        if computer_choice == user_choice:
            print(f"\nROUND {self.game_round}: You both chose {computer_choice}.")
            winner = "It's a tie! \n"
            self.game_round += 1
        elif (computer_choice == "rock" and user_choice == "paper") or (computer_choice == "paper" and user_choice == "scissors") or (computer_choice == "scissors" and user_choice == "rock"):
            print(f"\nROUND {self.game_round}: You chose {user_choice} and the computer chose {computer_choice}.")
            winner = "Congratulations! You won this round! \n"
            self.user_wins += 1
            self.game_round += 1
        elif (computer_choice == "rock" and user_choice == "scissors") or (computer_choice == "paper" and user_choice == "rock") or (computer_choice == "scissors" and user_choice == "paper"):
            print(f"\nROUND {self.game_round}: You chose {user_choice} and the computer chose {computer_choice}.")
            winner = "Oh no! You lost this round. Better luck next time. \n"
            self.computer_wins += 1
            self.game_round += 1
        else:
            print("\nI don't know what happened but none of the choices applied!")
            winner = "No winner. \n"
            self.game_round += 1
        
        print(winner)
        cv2.waitKey(3000)

        return winner


    def get_overall_winner(self):
        """
        A method to compute the overall winner and display the score.
        """

        print(f"\nGAME COMPLETE! The computer won {self.computer_wins} of the rounds and you won {self.user_wins} of the rounds.")
        
        if self.computer_wins < self.user_wins:
            print("CONGRATULATIONS! The overall winner is you! \n")
        elif self.computer_wins > self.user_wins:
            print("BAD LUCK! The overall winner is the computer. \n")
        else:
            print("There is no overall winner. It's a tie! \n")



def play():
    
    game = RPS()
    game.get_labels()
    
    while True:
        computer_choice = game.get_computer_choice()
        
        if args.mode == "keyboard":
            user_choice = game.get_keyboard_user_choice()
        
        elif args.mode == "camera":
            game.get_countdown()
            prediction_index = game.get_prediction()
            user_choice = game.get_camera_user_choice(prediction_index)
        
        game.get_winner(computer_choice, user_choice)

        if game.user_wins == 3 or game.computer_wins == 3 or game.game_round == 6:
            game.get_overall_winner()
            break
    
    if args.mode == "camera":
        game.cap.release()
        # Destroy all the windows
        cv2.destroyAllWindows()

if __name__ == "__main__":
    play()
    