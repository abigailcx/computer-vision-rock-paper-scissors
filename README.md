# **Computer Vision: Rock, Paper, Scissors** :fist: :scroll: :scissors:

## How to Play

### Logic of the Game
Play the classic game of rock, paper, scissors against the computer, using either your camera or keyboard input to show your move.
The code follows the classic rock, paper, scissors game logic where rock beats scissors, paper beats rock and scissors beats paper.

### How to Win
The first one (player or computer) to achieve 3 winning rounds wins the game. If neither achieves this within 5 rounds, the game ends and the one with the higher score is the winner.

### Set up the Environment
Use the following command to ensure all the dependencies are installed.
`pip install -r requirements.txt`

### Run the Code
Navigate to the computer-vision-rock-paper-scissors repo after cloning it.
Use `python game_rps.py` to play the game using the keyboard. When prompted, type the move you want to play.

Use `python game_rps.py -m camera` to play using the computer's camera.
If using camera mode, the terminal will prompt the player with a countdown and the message "Get ready to show your move!".
N.B. Due to the image data used to train the model, the game is best played with a plain light-coloured background and only a hand in the frame (no head/shoulders).

## Contents
This repo contains:
- `game_rps.py`: a multi-round OOP version of the game that can be played with either the keyboard or the camera
- `manual_rps.py`: a version which only takes in keyboard input and plays 1 round of the game
- `keras_model.h5`: the model trained in Teachable Machine
- `labels.txt`: the label config file, which relates each index to a move in the game
- `camera_rps.py`: [work in progress] a functional programming version of the game with only the camera implementation

## The Model

When using the camera mode to play, the game uses an image classification model to take the image of the player's move and predict which move it is. The model is trained with Google's Teachable Machine. 500 images were used for each of the 4 categories:
- Rock
- Paper
- Scissors
- Nothing

The code utilises the argmax function to find the highest probability in an array of 4 probabilities generated by Keras. This is stored in the variable called `prediction`. Each probability represents 1 of the 4 moves. The move corresponding to the highest probability is the predicted move. The code uses this prediction to compute the winner of each round.


## The Code
### The RPS Class
RPS contains all the methods for playing a game of rock, paper, scissors. It obtains the computer and user choices (either by keyboard input or by camera), finds the winner of each round as well as the overall winner.

### The Init Constructor
The init constructor contains the following parameters:

**moves** (list): labels from the 'labels.txt' file is read into this list

**prediction_index** (int): index of the highest probability in the array generated by Keras, initiated to 0

**computer_wins** (int): number of times the computer wins a round of the game (counter)

**user_wins** (int): number of times the user wins a round of the game (counter)

**game_round** (int): variable to keep track of the number of rounds of the game played, initiated to 1


### Methods
**get_countdown**: A static method to create and print a visible 3-second countdown to prompt the user to present their move to the camera.

**get_labels**: A method to read the `labels.txt` file generated by teachable machine and generate a list of moves. The index of each move relates to the index labels in the file. The output is a list of moves from the file: ['rock', 'paper', 'scissors', 'nothing'].

**get_computer_choice**: A method to generate the computer's move by randomly selecting an option from the list of moves (created by the `get_labels` method). The move 'Nothing' is excluded from the list of moves the computer can select.

**get_prediction**: A method to capture the image from the user's camera and and make a prediction of the move (rock, paper, scissors, nothing) with Tensorflow. The 'end' variable and 'while' loop allows the camera to capture frames for up to 2 seconds, at which point it must use the final frame to make the prediction. The prediction returns an array of the probability for each move, from which the highest probability is chosen using the argmax function. The method returns the index of the highest probability, which is used in the `get_user_choice` method to return the corresponding move to that index.

**get_camera_user_choice**: A method which takes in the index of the highest probability from the `prediction` array and returns the corresponding move to that index.

**get_keyboard_user_choice**: A method to ask the player to input their move via the keyboard and verify it.

**get_winner**: A method to compare the user choice and computer choice to determine the winner of a round.

**get_overall_winner**: A method to compute the overall winner and display the score.

## Future Functionality

- When the game finishes, ask the user whether they want to play another game

- Print out countdown, game scores, game round, user choice and computer choice on the camera screen itself, rather than in the terminal
